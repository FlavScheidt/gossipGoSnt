package main

import (
    "context"
    "io"
    "log"
    "flag"
    "fmt"
    "io/ioutil"
    "strings"
    mrand "math/rand"
    // "log/syslog"
    "os"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    pb "github.com/FlavScheidt/gossipGoSnt/proto"
    pubsub "github.com/libp2p/go-libp2p-pubsub"
)


// -----------------------------------------
//      Define ports
// -----------------------------------------
const gRPCportServer = "50051"
const sourcePort = 45511 //for libp2p

//Global, because I cannot modify the toRippled function
var nodeTopic *Topic

func main() {

    // -----------------------------------------
    //      Set log file
    // -----------------------------------------
    LOG_FILE := "./log.out"
    // open log file
    logFile, err := os.OpenFile(LOG_FILE, os.O_APPEND|os.O_RDWR|os.O_CREATE, 0644)
    if err != nil {
        log.Panic(err)
    }
    defer logFile.Close()

    mw := io.MultiWriter(os.Stdout, logFile)
    log.SetOutput(mw)

    // -----------------------------------------
    //      Create Context
    // -----------------------------------------
    ctx := context.Background()
    log.Println("Starting...")

    // -----------------------------------------
    //      Get the command line arguments
    //          We need to know which kind of experiment to run
    //          Here we just verify if the arguments are correct
    // -----------------------------------------
    experimentType := flag.String("type", "", "Type of experiment. Default is empty, shuts down")
    flag.Parse()

    log.Println(strings.ToLower(*experimentType))
    switch strings.ToLower(*experimentType) {
        case "general":
            log.Println("Experiment: One topic for everyone")
        case "validator":
            log.Println("Experiment: One topic per validator")
        case "unl":
            log.Println("Experiment: One topic per UNL")
        default:
            log.Println("Experiment type not recognized. Shutting down")
            return
    }

    // -----------------------------------------
    //      Create LibP2P node
    //          Need to do that for every type of experiment anyway
    // -----------------------------------------
    log.Println("------------------------------------------------------------------")
    log.Println("Libp2p Node")
    //Get node data
    thisNode := newNode()

    var r io.Reader

    //Use the name of the node to derive the key. Always derive the same key
    r = mrand.New(mrand.NewSource(int64(thisNode.id)))

    //Creates the new libp2p
    host, err := makeHost(sourcePort, r)
    if err != nil {
        log.Println(err)
        return
    }
    log.Println("ID: %s", host.ID().Pretty())
    log.Println("Multiaddresses:")
    for _, la := range host.Addrs() {
        log.Printf(" - %v\n", la)
    }

    //Create new GossipSub instance
    ps, err := pubsub.NewGossipSub(ctx, host)
    if err != nil {
        panic(err)
    }
    log.Println("GossipSub service created")

    // -----------------------------------------
    //      Libp2p Connections
    //          general connects statically with everyone in the peers list
    //          the other two make a dynamic discovery in the network using mDNS
    // -----------------------------------------
    if strings.ToLower(*experimentType) == "general" {
        //First we try to connect to everyone on the list
        for i := 0; i<len(thisNode.peersList); i++ {
            peerAddr := getPeerMultAddr(thisNode.peersList[i])

            rw, err := startPeerAndConnect(ctx, host, peerAddr)
            if err != nil {
               log.Println("Peer is not online... Next one.")
            } else {
                go writeData(rw)
                go readData(rw)
            }
        }

        //Now we wait for incoming connections
        startPeer(ctx, host, handleStream)
    } else {
        log.Println("Finding peers...")
        // setup local mDNS discovery
        if err := setupDiscovery(host); err != nil {
            panic(err)
        }
    }
    log.Println("------------------------------------------------------------------")

    // -----------------------------------------
    //      gRPC Client
    // -----------------------------------------
    //Get node ephemeral key generated by rippled
    ephKeyBytes, err := ioutil.ReadFile("/root/sntrippled/my_build/key.out")
    if err != nil {
        log.Fatal(err)
    }
    ephKey := strings.TrimSpace(fmt.Sprintf("%s",ephKeyBytes))
    log.Println("------------------------------------------------------------------")
    log.Println("GRPC Node")
    log.Println("Rippled ephemeral key: ", ephKey)

    var conn *grpc.ClientConn
    conn, err = grpc.Dial("localhost:20052", grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        log.Fatalf("did not connect: %s", err)
    }
    defer conn.Close()

    c := pb.NewGossipMessageClient(conn)

    log.Println("Stub Created")
    log.Println("------------------------------------------------------------------")

    // -----------------------------------------
    //      GossipSub
    // -----------------------------------------
    log.Println("------------------------------------------------------------------")
    log.Println("GossipSub")

    //Joining topics
    switch strings.ToLower(*experimentType) {
    case "general":

        //Create peerInfo for everything
        validationsTopic    := peerInfo{name:"validations", id:0, ip: ""}
        // proposalsTopic      = peerInfo{name: "proposals", id: 0, ip: ""}

        nodeTopic, err = Subscribe(ctx, ps, c, host.ID(), validationsTopic)
        if err != nil {
            panic(err)
        }
        log.Println("Joined topic for ", nodeTopic.name)

    case "validator":
        var topicsList []*Topic
        var topicAux *Topic

        //First, subscrive to nodes own topic
        nodeTopic, err = Subscribe(ctx, ps, c, host.ID(), peerInfo{name: thisNode.name})
        if err != nil {
            panic(err)
        }
        log.Println("Joined own topic")

        //Subscribe to each topic in the peers list
        for i := 0; i<len(thisNode.peersList); i++ {
            topicAux, err = Subscribe(ctx, ps, c, host.ID(), thisNode.peersList[i])
            topicsList = append(topicsList, topicAux)
            if err != nil {
                panic(err)
            }
            log.Println("Joined topic for ", topicsList[i].name)
        }
    case "unl":
        log.Println("Not implemented. Shutting down...")
        return

    }
    log.Println("------------------------------------------------------------------")

    
    
    // -----------------------------------------
    //      gRPC Server
    // -----------------------------------------
    log.Println("------------------------------------------------------------------")
    log.Println("GRPC Server")

    go gRPCserver()

    // Wait forever
    select {}

}
