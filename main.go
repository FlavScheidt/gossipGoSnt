package main

import (
    "context"
    "io"
    "log"
    mrand "math/rand"
)

const gRPCport := "20052"
const sourcePort := 45511 //for libp2p


func main() {

    //TRANSLATE THIS TO GO
    //Gets node own ephemeral key
    // const { execSync } = require("child_process");
    // bash_command = 'cat ../my_build/key.out'
    // var validatorKey = execSync(bash_command);
    // validatorKey = validatorKey.toString().replace( /[\r\n]+/gm, "" );
    //Get node ephemeral key generated by rippled
    ephKey, err := ioutil.ReadFile("/root/sntrippled/my_build/key.out")
    if err != nil {
        log.Fatal(err)
    }
    ephKey =  strings.TrimSpace(fmt.Sprintf("%s",nodeName))

    //gRPC stuff
    log.Println("------------------------------------------------------------------")
    log.Println("GRPC Node")
    log.Println("Rippled ephemeral key: %s", ephKey)
    //Start gRPC Server
    gRPCServer()
    //Start gRPC Client
    gRPCClient()

    //Libp2p
    log.Println("------------------------------------------------------------------")
    log.Println("Libp2p")
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()


    //Get node data
    thisNode := newNode()

    var r io.Reader

    //Use the name of the node to derive the key. Always derive the same key
    r = mrand.New(mrand.NewSource(int64(thisNode.id)))

    //Creates the new libp2p
    host, err := makeHost(sourcePort, r)
    if err != nil {
        log.Println(err)
        return
    }
    log.Println("ID: %s", host.ID().Pretty())
    log.Println("Multiaddresses:")
    for _, la := range h.Addrs() {
        log.Printf(" - %v\n", la)
    }

    //Create new GossipSub instance
    // ps, err := pubsub.NewGossipSub(ctx, h)
    // if err != nil {
    //     panic(err)
    // }

    //First we try to connect to everyone on the list
    for i := 0; i<len(thisNode.peersList); i++ {
        peerAddr := getPeerMultAddr(thisNode.peersList[i])

        rw, err := startPeerAndConnect(ctx, host, peerAddr)
        if err != nil {
           log.Println("Peer is not online... Next one.")
        } else {
            go writeData(rw)
            go readData(rw)
        }
    }

    //Now we wait for incoming connections
    startPeer(ctx, host, handleStream)

    // Wait forever
    select {}

}